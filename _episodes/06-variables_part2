> {: .solution}
{: .challenge}

We place variables at the top of a Makefile so they are easy to
find and modify. Alternatively, we can pull them out into a new
file that just holds variable definitions (i.e. delete them from
the original makefile). Let us create `config.mk`:

~~~
# Count words script.
COUNT_SRC=wordcount.py
COUNT_EXE=python $(COUNT_SRC)

# Test Zipf's rule
ZIPF_SRC=zipf_test.py
ZIPF_EXE=python $(ZIPF_SRC)
~~~
{: .make}

We can then import `config.mk` into `Makefile` using:

~~~
include config.mk
~~~
{: .make}

We can re-run Make to see that everything still works:

~~~
$ make clean
$ make dats
$ make results.txt
~~~
{: .bash}

We have separated the configuration of our Makefile from its rules,
the parts that do all the work. If we want to change our script name
or how it is executed we just need to edit our configuration file, not
our source code in `Makefile`. Decoupling code from configuration in
this way is good programming practice, as it promotes more modular,
flexible and reusable code.

> ## Where We Are
>
> [This Makefile]({{ site.github.url }}/code/06-variables/Makefile)

